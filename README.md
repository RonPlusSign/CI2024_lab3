# CI2024_lab2: n-puzzle problem
This project contains my 3 solutions for the n-puzzle problem, which is a puzzle game consisting of a board of `n Ã— n` cells, where `n` is an integer and `n > 2`.
The board contains `n^2 - 1` tiles numbered from `1` to `n^2 - 1`, and one empty cell (represented by the value `0` in this project).\
The goal of the game is to rearrange the tiles in the board to reach a goal configuration, by moving one of the adjacent tiles into the empty cell.\
The goal is a configuration where the tiles are ordered from `1` to `n^2 - 1` in row-major order,
and the empty cell is in the bottom-right corner of the board.

The project contains 3 solutions for the n-puzzle:
1. Depth First Search (DFS)
2. Breadth First Search (BFS)
3. A* Search Algorithm

The initial puzzle configuration is generated by shuffling the goal configuration with 100000 valid steps.

## Solution 1: Depth First Search (DFS)

Depth First Search (DFS) is an algorithm for traversing or searching tree or graph data structures.
The algorithm starts at the root node (in this case the initial puzzle configuration) and explores as far as possible along each branch before backtracking.

The version of DFS I implemented has a **fixed maximum depth**, in order to avoid non-termination, cycles and memory overflow.

Algorithm steps:
1. Begin the search at the initial puzzle configuration and push it onto a stack
2. Pop the top node from the stack, mark it as visited, and process it (check if it is the goal, if not, generate its children)
3. Push all unvisited adjacent nodes of the current node onto the stack (puzzle configurations that can be reached from the current configuration by moving a tile)
4. Repeat steps 2 and 3 until the stack is empty or the goal is found.

DFS has been implemented using a *stack* data structure, and can be done either iteratively (as I did) or via recursion.\
Each element of the stack is composed by 3 elements:
- The current puzzle configuration
- The history of how the current configuration was reached
- The depth of the current configuration (used to restrict the search up to a maximum depth)


### Issues of DFS:
- DFS may not find the shortest path to the goal node, because a maximum depth of the tree is reached before backtracking
- Increasing the maximum depth of the tree may lead to a memory overflow or non-termination
- The computational cost is higher when compared to the other 2 solutions

> Note: sometimes this algorithm fails to find a solution even for 3x3 puzzles, and thus it cannot be considered a good solution.

## Solution 2: Breadth First Search (BFS)

Breadth First Search (BFS) is an algorithm for traversing or searching tree or graph data structures.
The algorithm starts at the root node (in this case the initial puzzle configuration) and explores all neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.

Algorithm steps:
1. Begin the search at the initial puzzle configuration and push it onto a queue
2. Pop the front node from the queue, mark it as visited, and process it (check if it is the goal, if not, generate its children)
3. Push all unvisited adjacent nodes of the current node onto the queue (puzzle configurations that can be reached from the current configuration by moving a tile)
4. Repeat steps 2 and 3 until the queue is empty or the goal is found.

BFS has been implemented using a *queue* data structure.\
Each element of the queue is composed by 2 elements:
- The current puzzle configuration
- The history of how the current configuration was reached

### Issues of BFS:
- High memory usage, because it stores all the nodes at the current depth level
- The computational cost is higher when compared to the A* algorithm
- The algorithm may take a long time to find a solution for large puzzles

> Note: this algorithm fails to find a solution for 4x4 puzzles because it finishes all the available memory of a 32GB RAM machine.
> For 3x3 puzzles, the algorithm takes a few seconds to find a solution.

## Solution 3: A* Search Algorithm

A* is a graph traversal and path search algorithm, which is widely used in many fields of computer science due to its completeness, optimality, and optimal efficiency.
The algorithm uses a best-first search and finds the least-cost path from the initial node to the goal node.

The A* algorithm evaluates nodes by combining the cost to reach the node (g) and the cost to get from the node to the goal (h).


## Solution 3: A* Algorithm

The A* algorithm is a search algorithm designed to solve optimization problems like the n-puzzle efficiently. It uses a combination of the **path cost** (`g`, the number of moves so far) and a **heuristic estimate** (`h`, the estimated moves to reach the goal) to prioritize exploration. This ensures an optimal solution if the puzzle is solvable.

### Algorithm steps:
- Initialize the priority queue with the starting configuration (`state`) as a tuple, a `path` containing just the starting state, and a path cost `g = 0`. 
- While the priority queue is not empty:
  1. Pop the state with the lowest `f = g + h`.
  2. If the state is the goal (`is_goal`), return the `path` to the solution.
  3. If the state was already visited, skip it. Otherwise, mark it as visited.
  4. For each valid action, generate a new state by moving a tile:
     - Calculate the new path cost `g` and heuristic `h`
     - Add the new state to the priority queue along with its updated cost and path history

Each element in the queue contains:
- The priority `f = g + h`
- A tiebreaker to prioritize states with the same priority (FIFO)
- The current puzzle configuration
- The history leading to the current state
- The path cost `g` to reach the current state

### Heuristic:
The **Manhattan Distance** heuristic is used, which calculates the sum of the distances of each tile from its goal position. This heuristic is admissible (never overestimates) and ensures the A\* algorithm finds an optimal solution.

### Advantages of A*:
- Guarantees the shortest path to the goal configuration
- Uses an admissible heuristic to prioritize states closer to the solution

### Issues of A*:
- Memory-intensive: Stores all visited and queued states, leading to high memory usage
- Computationally expensive for larger puzzles (`n > 4`) due to exponential growth of states

> Note: The A\* algorithm performs well for puzzles up to `4x4`, solving them optimally and efficiently. However, for larger puzzles (`5x5` or greater), its memory and computational requirements make it impractical without additional optimizations.